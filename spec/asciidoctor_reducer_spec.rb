# frozen_string_literal: true

require_relative 'spec_helper'

describe 'Asciidoctor::Reducer' do
  it 'should provide VERSION constant' do
    (expect Asciidoctor::Reducer::VERSION).to match %r/^\d+\.\d+\.\d+(\.\S+)?$/
  end

  it 'should resolve top-level include with no includes' do
    doc = Asciidoctor.load_file (fixture_file 'parent-with-single-include.adoc'), safe: :safe
    expected_lines = <<~'EOS'.chomp.split ?\n
    before include

    no includes here

    just good old-fashioned paragraph text

    after include
    EOS
    (expect doc.source_lines).to eql expected_lines
    (expect doc.blocks.size).to be 4
    (expect (doc.blocks.map {|it| it.lineno })).to eql [1, 3, 5, 7]
  end

  it 'should resolve top-level include with nested include' do
    doc = Asciidoctor.load_file (fixture_file 'parent-with-single-include-with-include.adoc'), safe: :safe
    expected_lines = <<~'EOS'.chomp.split ?\n
    before include

    before nested include

    no includes here

    just good old-fashioned paragraph text

    after nested include

    after include
    EOS
    (expect doc.source_lines).to eql expected_lines
    (expect doc.blocks.size).to be 6
    (expect (doc.blocks.map {|it| it.lineno })).to eql [1, 3, 5, 7, 9, 11]
  end

  it 'should resolve nested include relative to include file' do
    doc = Asciidoctor.load_file (fixture_file 'parent-with-nested-include-in-subdir.adoc'), safe: :safe
    expected_lines = <<~'EOS'.chomp.split ?\n
    before include

    before relative include

    contents of relative include

    after relative include

    after include
    EOS
    (expect doc.source_lines).to eql expected_lines
    (expect doc.blocks.size).to be 5
    (expect (doc.blocks.map {|it| it.lineno })).to eql [1, 3, 5, 7, 9]
  end

  it 'should resolve include with single line paragraph' do
    doc = Asciidoctor.load_file (fixture_file 'parent-with-include-with-single-line-paragraph.adoc'), safe: :safe
    expected_lines = <<~'EOS'.chomp.split ?\n
    before include

    single line paragraph

    after include
    EOS
    (expect doc.source_lines).to eql expected_lines
    (expect doc.blocks.size).to be 3
    (expect (doc.blocks.map {|it| it.lineno })).to eql [1, 3, 5]
  end

  it 'should skip top-level include that cannot be resolved' do
    doc = nil
    with_memory_logger do |logger|
      doc = Asciidoctor.load_file (fixture_file 'parent-with-unresolved-include.adoc'), safe: :safe
      (expect logger).to be_empty
    end
    expected_lines = <<~'EOS'.chomp.split ?\n
    before include

    include::no-such-file.adoc[]

    after include
    EOS
    (expect doc.source_lines).to eql expected_lines
    (expect doc.blocks.size).to be 3
    (expect (doc.blocks.map {|it| it.lineno })).to eql [1, 3, 5]
  end

  it 'should skip empty include' do
    doc = Asciidoctor.load_file (fixture_file 'parent-with-empty-include.adoc'), safe: :safe
    expected_lines = <<~'EOS'.chomp.split ?\n
    before include
    after include

    before include


    after include
    EOS
    (expect doc.source_lines).to eql expected_lines
    (expect doc.blocks.size).to be 3
    (expect (doc.blocks.map {|it| it.lineno })).to eql [1, 4, 7]
  end

  it 'should not log messages generated by document' do
    with_memory_logger do |logger|
      Asciidoctor.load_file (fixture_file 'document-with-warnings.adoc'), safe: :safe
      (expect logger.messages).to be_empty
      (expect logger).to be Asciidoctor::LoggerManager.logger
    end
  end
end
